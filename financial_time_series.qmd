---
title: "Financial Time Series Models (ARCH/GARCH)"
---

Applying ARCH or GARCH models to the healthcare stocks like [Pfizer (PFE)](https://en.wikipedia.org/wiki/Pfizer), [Vertex Pharmaceuticals (VRTX)](https://en.wikipedia.org/wiki/Vertex_Pharmaceuticals), [TEVA Pharmaceutical(TEVA)](https://en.wikipedia.org/wiki/Teva_Pharmaceuticals), and [Sage Therapeutics (SAGE)](https://www.sagerx.com) can be a valuable method for us to understand and forecast the volatility of these stocks.

The ARCH model would allow us to model the volatility as a function of the size of previous time periods' errors, capturing short-term fluctuations. In contrast, the GARCH model would incorporate both these shocks and the persistent volatility over time, which could provide a more comprehensive understanding of the volatility structure in these healthcare stocks.

The decision to use ARCH versus GARCH would depend on the characteristics of the stock's return series---specifically, whether the volatility shocks are short-lived (suggesting ARCH) or whether they have a more enduring impact (suggesting GARCH). Before applying these models, it's crucial for us to conduct preliminary analyses such as checking for stationarity, identifying the presence of volatility clustering, and determining the optimal lag length for the models.

```{r setup, include=FALSE}
library(tidyverse)
library(ggplot2)
library(forecast)
library(astsa) 
library(xts)
library(tseries)
library(fma)
library(lubridate)
library(TSstudio)
library(quantmod)
library(tidyquant)
library(plotly)
library(gridExtra)
library(tidyverse)  
library(lubridate)   
library(fpp2)          
library(zoo)   
library(forecast)
library(imputeTS)
library(fpp2)
library(corrplot)
library(car)
library(caTools)
library(FinTS)
library(rugarch)
library(fGarch)

```

```{r load_data, warning=FALSE, message=FALSE}
#| code-fold: true

# Import Stock Price data
options("getSymbols.warning4.0"=FALSE)
options("getSymbols.yahoo.warning"=FALSE)

tickers = c("PFE", "VRTX", "TEVA", "SAGE")

for (i in tickers){
  getSymbols(i,
             from = "2019-01-01",
             to = "2024-02-02")}

x <- list(
  title = "date"
)
y <- list(
  title = "value"
)

stock <- data.frame(PFE$PFE.Adjusted,
                    VRTX$VRTX.Adjusted,
                    TEVA$TEVA.Adjusted,
                    SAGE$SAGE.Adjusted)


stock <- data.frame(stock,rownames(stock))
colnames(stock) <- append(tickers,'Dates')

stock <- stock %>%
  rownames_to_column(var = "date")

stock$date<-as.Date(stock$Dates,"%Y-%m-%d")

# Extract every stock price
pfizer <- getSymbols("PFE", from = "2019-01-01", to = "2024-02-02", src = "yahoo", auto.assign = FALSE)
vertex <- getSymbols("VRTX", from = "2019-01-01", to = "2024-02-02", src = "yahoo", auto.assign = FALSE)
teva <- getSymbols("TEVA", from = "2019-01-01", to = "2024-02-02", src = "yahoo", auto.assign = FALSE)
sage <- getSymbols("SAGE", from = "2019-01-01", to = "2024-02-02", src = "yahoo", auto.assign = FALSE)
```

# Data Visualization

::: panel-tabset
## Pfizer

```{r plot_pfe}
#| code-fold: true

chartSeries(pfizer, theme = chartTheme("white"),
            bar.type = "hlc",  
            up.col = "green",  
            dn.col = "red") 
```

For Pfizer's stock price from January 2019 to February 2024. There were fluctuations during 2020, but an overall increase trend can be observed, which is due to the COVID-19 pandemic and the development of the COVID-19 vaccine. However, for recent years, the stock price has been decreasing with some fluctuations.

## Vertex

```{r plot_vertex}
#| code-fold: true

chartSeries(vertex, theme = chartTheme("white"),
            bar.type = "hlc",  
            up.col = "green",  
            dn.col = "red") 
```

For Vertex Pharmaceuticals' stock price from January 2019 to February 2024, the stock price has been decreasing in the beginning of 2020, but it has been increasing significantly since March 2022, with some fluctuations. The significant increase in Vertex stock price could be attributed to several factors: Successful Drug Developments, Strategic Partnerships or Acquisitions with other companies for drug development or expansion into new markets, and Breakthroughs in biotechnology or patents for new drug formulas.

## Teva

```{r plot_teva}
#| code-fold: true

chartSeries(teva, theme = chartTheme("white"),
            bar.type = "hlc",  
            up.col = "green",  
            dn.col = "red") 

```

For TEVA stock price from January 2019 to February 2024. The stock price has been decreasing hugely since 2019, reaching its lowest point in 2020. Since then, the stock price has been relatively stable with fluctuations.

## Sage

```{r plot_sage}
#| code-fold: true

chartSeries(sage, theme = chartTheme("white"),
            bar.type = "hlc",  
            up.col = "green",  
            dn.col = "red") 

```

For Sage Therapeutics' stock price from January 2019 to February 2024, the stock price has been decreasing since the middle of 2019 too, with some fluctuations. Then it has been increasing, reaching the peak in 2021, and then decreasing a little again, then stay stable with some fluctuations.
:::

# Stock Returns

::: panel-tabset
## Pfizer

```{r pfe_returns}
#| code-fold: true

pfe_ts <- ts(pfizer$PFE.Adjusted, start=decimal_date(as.Date("2019-01-01")), frequency = 365.25)

returns_pfe = log(pfe_ts) %>% 
  diff()

# Plot the PFE returns
autoplot(returns_pfe, color="#27aeef") + theme_bw() +ggtitle("Pfizer Returns")
```

The returns of Pfizer stock price shows clear **volatility clustering**. The returns are centered around zero, with some extreme values indicating high volatility. The periods of high volatility are around the beginning of 2020 and 2021, which could be due to the COVID-19 pandemic and the development of the COVID-19 vaccine.

## Vertex

```{r vertex_returns}
#| code-fold: true

vertex_ts <- ts(vertex$VRTX.Adjusted, start=decimal_date(as.Date("2019-01-01")), frequency = 365.25)

returns_vertex = log(vertex_ts) %>% 
  diff()

# Plot the VRTX returns
autoplot(returns_vertex, color="#27aeef") + theme_bw() +ggtitle("Vertex Returns")

```

The returns of Vertex stock price are centered around zero, with some extreme values indicating high volatility. The periods of high volatility are in the end of 2019, the middle of 2020, and the middle of 2022, which could be due to the company's financial performance, drug developments, or COVID-19 pandemic.

## Teva

```{r teva_returns}
#| code-fold: true

teva_ts <- ts(teva$TEVA.Adjusted, start=decimal_date(as.Date("2019-01-01")), frequency = 365.25)

returns_teva = log(teva_ts) %>% 
  diff()

# Plot the TEVA returns
autoplot(returns_teva, color="#27aeef") + theme_bw() +ggtitle("Teva Returns")
```

The returns of TEVA stock price shows clear **volatility clustering**. The returns are centered around zero, with some extreme values indicating high volatility. The periods of high volatility are around the end of 2019, and there was a high spike in the middle of 2021, which could be due to the company's financial performance, drug developments, or COVID-19 pandemic.

## Sage

```{r sage_returns}
#| code-fold: true

sage_ts <- ts(sage$SAGE.Adjusted, start=decimal_date(as.Date("2019-01-01")), frequency = 365.25)

returns_sage = log(sage_ts) %>% 
  diff()

# Plot the SAGE returns
autoplot(returns_sage, color="#27aeef") + theme_bw() +ggtitle("Sage Returns")

```

The Sage Therapeutics' stock returns are fluctuating around zero, but two large negative spikes of the **volatility** stand out---one in late 2019 and another in early 2022. These could indicate significant stock price drops, possibly due to negative clinical trial results, regulatory setbacks, poor financial performance, or COVID-19. Between these events, returns show **regular volatility**, which is common in biotech stocks due to the high-impact nature of news on drug development progress.
:::

# ACF/PACF Plots

::: panel-tabset
## Pfizer

After analyzing the ACF and PACF plots for `Pfizer`'s stock returns, we can see significant lags at p = 1, 9, 10, q = 1, 9, 10. This indicates that the returns are not stationary and exhibit significant autocorrelation at these lags. Besides, we can see the returns of Pfizer are **most stationary** without high correlation.

```{r pfe_acf_pacf}
#| code-fold: true

plot1<-ggAcf(returns_pfe, 40)+ggtitle("Pfizer Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_pfe, 40)+theme_bw()+ggtitle("Pfizer Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Here, I will check the ACF and PACF plots for the **absolute returns** of Pfizer's stock price. We can see that the PACF plot shows significant lags at p = 1, 2, 3, 4, 5, 8, and the ACF plot shows significant lags at q = 1 to 10 and so on.

```{r pfe_abs_acf_pacf}
#| code-fold: true

plot1<-ggAcf(abs(returns_pfe), 40)+ggtitle("Pfizer Absolute Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(abs(returns_pfe), 40)+theme_bw()+ggtitle("Pfizer Absolute Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Then, let's check the ACF and PACF plots for the **squared returns** of Pfizer's stock price. We can see that the PACF plot shows significant lags at p = 1, 2, 3, 4, 5, 7, 8, and the ACF plot shows significant lags at q = 1 to 10 and so on.

```{r pfe_sq_acf_pacf}
#| code-fold: true


plot1<-ggAcf(returns_pfe^2, 40)+ggtitle("Pfizer Squared Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_pfe^2, 40)+theme_bw()+ggtitle("Pfizer Squared Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

## Vertex

After analyzing the ACF and PACF plots for `Vertex`'s stock returns, we can see significant lags at p = 1, 6, 7, 8, 9, q = 1, 6, 7, 8, 9. This indicates that the returns are not stationary and exhibit significant autocorrelation at these lags. Besides, we can see the returns of Vertex are **most stationary** without high correlation.

```{r vertex_acf_pacf}
#| code-fold: true

plot1<-ggAcf(returns_vertex, 40)+ggtitle("Vertex Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_vertex, 40)+theme_bw()+ggtitle("Vertex Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Here, I will check the ACF and PACF plots for the **absolute returns** of Vertex's stock price. We can see that the PACF plot shows significant lags at p = 1, 2, 3, 4, 5, 6, 7, 9, and the ACF plot shows significant lags at q = 1 to 10 and so on.

```{r vertex_abs_acf_pacf}
#| code-fold: true

plot1<-ggAcf(abs(returns_vertex), 40)+ggtitle("Vertex Absolute Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(abs(returns_vertex), 40)+theme_bw()+ggtitle("Vertex Absolute Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Then, let's check the ACF and PACF plots for the **squared returns** of Vertex's stock price. We can see that the PACF plot shows significant lags at p = 1, and the ACF plot shows significant lags at q = 1, 7, 9.

```{r vertex_sq_acf_pacf}
#| code-fold: true


plot1<-ggAcf(returns_vertex^2, 40)+ggtitle("Vertex Squared Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_vertex^2, 40)+theme_bw()+ggtitle("Vertex Squared Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

## Teva

After analyzing the ACF and PACF plots for `TEVA`'s stock returns, we can see significant lags at p = 14, q = 14. This indicates that the returns are not stationary and exhibit significant autocorrelation at these lags. Besides, we can see the returns of TEVA are **most stationary** without high correlation.

```{r teva_acf_pacf}
#| code-fold: true

plot1<-ggAcf(returns_teva, 40)+ggtitle("TEVA Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_teva, 40)+theme_bw()+ggtitle("TEVA Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Here, I will check the ACF and PACF plots for the **absolute returns** of Teva's stock price. We can see that the PACF plot shows significant lags at p = 1, 2, 3, 4, 6, 7, and the ACF plot shows significant lags at q = 1 to 10 and so on.

```{r teva_abs_acf_pacf}
#| code-fold: true

plot1<-ggAcf(abs(returns_teva), 40)+ggtitle("TEVA Absolute Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(abs(returns_teva), 40)+theme_bw()+ggtitle("TEVA Absolute Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Then, let's check the ACF and PACF plots for the **squared returns** of Teva's stock price. We can see that the PACF plot shows significant lags at p = 1, 2, 5, 10 and the ACF plot shows significant lags at q = 1, 2, 3, 4, 5, 10.

```{r teva_sq_acf_pacf}
#| code-fold: true


plot1<-ggAcf(returns_teva^2, 40)+ggtitle("TEVA Squared Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_teva^2, 40)+theme_bw()+ggtitle("TEVA Squared Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

## Sage

After analyzing the ACF and PACF plots for `SAGE`'s stock returns, we can see significant lags at p = 4, 8, q = 4, 8. This indicates that the returns are not stationary and exhibit significant autocorrelation at these lags. Besides, we can see the returns of SAGE are **most stationary** without high correlation.

```{r sage_acf_pacf}
#| code-fold: true

plot1<-ggAcf(returns_sage, 40)+ggtitle("SAGE Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_sage, 40)+theme_bw()+ggtitle("SAGE Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Here, I will check the ACF and PACF plots for the **absolute returns** of Sage's stock price. We can see that the PACF plot shows significant lags at p = 1, 4, and the ACF plot shows significant lags at q = 1, 4, 8.

```{r sage_abs_acf_pacf}
#| code-fold: true

plot1<-ggAcf(abs(returns_sage), 40)+ggtitle("SAGE Absolute Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(abs(returns_sage), 40)+theme_bw()+ggtitle("SAGE Absolute Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```

Then, let's check the ACF and PACF plots for the **squared returns** of Sage's stock price. We can see that none of the lags are significant in the PACF plot and the ACF plot.

```{r sage_sq_acf_pacf}
#| code-fold: true


plot1<-ggAcf(returns_sage^2, 40)+ggtitle("SAGE Squared Returns ACF") + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(returns_sage^2, 40)+theme_bw()+ggtitle("SAGE Squared Returns PACF")+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)
```
:::

# ARCH Test

In this section, I'll use the **ARCH test** to check for the presence of ARCH effects in the stock returns of Pfizer, Vertex, Teva, and Sage. The null hypothesis of the ARCH test is that there are no ARCH effects (the presence of heteroskedasticity or varying volatility) in the data. If the p-value is less than 0.05, then we can reject the null hypothesis and conclude that there are ARCH effects in the data. The ARCH test is often applied to financial market data where volatility clustering occurs---periods of high volatility are followed by high volatility, and periods of low volatility follow low volatility. The ARCH test evaluates whether past error terms can predict future variance, implying that the error terms have a pattern rather than being random. If the ARCH effect is present, models such as ARCH or GARCH might be suitable for capturing this characteristic in the data.

::: panel-tabset
## Pfizer

```{r pfizer_arch_test}
#| code-fold: true

ArchTest(returns_pfe, lags=31, demean=TRUE)
```

As we can see, the p-value of the ARCH test for `Pfizer`'s stock returns is less than 0.05, indicating that there are ARCH effects in the data. This suggests that the volatility of Pfizer's stock returns is not constant and exhibits clustering behavior.

## Vertex

```{r vertex_arch_test}
#| code-fold: true

ArchTest(returns_vertex, lags=31, demean=TRUE)
```

As we can see, the p-value of the ARCH test for `Vertex`'s stock returns is more than 0.05, indicating that there are not ARCH effects in the data. This suggests that the volatility of Vertex's stock returns is constant and may not exhibit clustering behavior.

## Teva

```{r teva_arch_test}
#| code-fold: true

ArchTest(returns_teva, lags=31, demean=TRUE)
```

As we can see, the p-value of the ARCH test for `Teva`'s stock returns is less than 0.05, indicating that there are ARCH effects in the data. This suggests that the volatility of Teva's stock returns is not constant and may exhibit clustering behavior.

## Sage

```{r sage_arch_test}
#| code-fold: true

ArchTest(returns_sage, lags=31, demean=TRUE)
```

As we can see, the p-value of the ARCH test for `Sage`'s stock returns is more than 0.05, indicating that there are no ARCH effects in the data. This suggests that the volatility of Sage's stock returns is constant and may not exhibit clustering behavior.
:::

# Fitting the ARIMA Model

In this section, I'll fit an ARIMA model on the **returns** firstly.

::: panel-tabset
## Pfizer

As we can see from the ACF and PACF plots before, the data is already mostly stationary, so it's not necessary to difference the data.

```{r pfizer_arima}
#| code-fold: true

# p = 1:10, d = 0, q = 1:10

ARIMA.c=function(p1,p2,q1,q2,data){
temp=c()
d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*15),nrow=15)


for (p in p1:p2)#
{
  for(q in q1:q2)#
  {
    for(d in 0:0)#
    {
      
      if(p+d+q<=6)
      {
        
        model<- Arima(data,order=c(p,d,q))
        ls[i,]= c(p,d,q,model$aic,model$bic,model$aicc)
        i=i+1
  
        
      }
      
    }
  }
}


temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp
}

output <- ARIMA.c(1,10,1,10,data=returns_pfe)
output
output[which.min(output$AIC),]
output[which.min(output$BIC),]
output[which.min(output$AICc),]

```

As we can see, the best model according to BIC is **ARIMA(1,0,2)**. This model's AIC is quite close to the other two models, but the BIC is the lowest among the three. Considering the principle of parsimony, we'll choose **ARIMA(1,0,2)** as the best model for Pfizer's stock returns.

```{r pfizer_arima_fit}
#| code-fold: true

fit_pfe <- Arima(returns_pfe,order=c(1,0,2))
summary(fit_pfe)
```

After fitting ARIMA(1,0,2) to the data, we can see that there is one insignificant coefficient in the model on the 0.05 significance level, which is MA(1).

## Vertex

As we can see from the ACF and PACF plots before, the data is already mostly stationary, so it's not necessary to difference the data.

```{r vertex_arima}
#| code-fold: true

# p = 1:9, d = 0, q = 1:9

ARIMA.c=function(p1,p2,q1,q2,data){
temp=c()
d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*15),nrow=15)


for (p in p1:p2)#
{
  for(q in q1:q2)#
  {
    for(d in 0:0)#
    {
      
      if(p+d+q<=6)
      {
        
        model<- Arima(data,order=c(p,d,q))
        ls[i,]= c(p,d,q,model$aic,model$bic,model$aicc)
        i=i+1
  
        
      }
      
    }
  }
}


temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp
}

output <- ARIMA.c(1,9,1,9,data=returns_vertex)
output
output[which.min(output$AIC),]
output[which.min(output$BIC),]
output[which.min(output$AICc),]
```

As we can see, the best model according to AIC, BIC, and AICc is **ARIMA(3,0,3)**.

```{r vertex_arima_fit}
#| code-fold: true

fit_vertex <- Arima(returns_vertex,order=c(3,0,3))
summary(fit_vertex)
```

After fitting ARIMA(3,0,3) to the data, we can see that there is no significant coefficient in the model on the 0.05 significance level.

## Teva

As we can see from the ACF and PACF plots before, the data is already mostly stationary, so it's not necessary to difference the data.

```{r teva_arima}
#| code-fold: true

# p = 1:14, d = 0, q = 1:14

ARIMA.c=function(p1,p2,q1,q2,data){
temp=c()
d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*20),nrow=20)


for (p in p1:p2)#
{
  for(q in q1:q2)#
  {
    for(d in 0:0)#
    {
      
      if(p+d+q<=6)
      {
        
        model<- Arima(data,order=c(p,d,q))
        ls[i,]= c(p,d,q,model$aic,model$bic,model$aicc)
        i=i+1
  
        
      }
      
    }
  }
}


temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp
}

output <- ARIMA.c(1,14,1,14,data=returns_teva)
output
output[which.min(output$AIC),]
output[which.min(output$BIC),]
output[which.min(output$AICc),]
```

As we can see, the best model according to BIC is **ARIMA(1,0,1)**. This model's AIC is quite close to the other two models, but the BIC is the lowest among the three. Considering the principle of parsimony, we'll choose **ARIMA(1,0,1)** as the best model for Teva's stock returns.

```{r teva_arima_fit}
#| code-fold: true

fit_teva <- Arima(returns_teva,order=c(1,0,1))
summary(fit_teva)
```

After fitting ARIMA(1,0,1) to the data, we can see that there is no significant coefficient in the model on the 0.05 significance level.

## Sage

As we can see from the ACF and PACF plots before, the data is already mostly stationary, so it's not necessary to difference the data.

```{r sage_arima}
#| code-fold: true

# p = 1:8, d = 0, q = 1:8

ARIMA.c=function(p1,p2,q1,q2,data){
temp=c()
d=1
i=1
temp= data.frame()
ls=matrix(rep(NA,6*15),nrow=15)


for (p in p1:p2)#
{
  for(q in q1:q2)#
  {
    for(d in 0:0)#
    {
      
      if(p+d+q<=6)
      {
        
        model<- Arima(data,order=c(p,d,q))
        ls[i,]= c(p,d,q,model$aic,model$bic,model$aicc)
        i=i+1
  
        
      }
      
    }
  }
}


temp= as.data.frame(ls)
names(temp)= c("p","d","q","AIC","BIC","AICc")

temp
}

output <- ARIMA.c(1,8,1,8,data=returns_sage)
output
output[which.min(output$AIC),]
output[which.min(output$BIC),]
output[which.min(output$AICc),]
```

As we can see, the best model according to BIC is **ARIMA(1,0,1)**. This model's AIC is quite close to the other two models, but the BIC is the lowest among the three. Considering the principle of parsimony, we'll choose **ARIMA(1,0,1)** as the best model for Sage's stock returns.

```{r sage_arima_fit}
#| code-fold: true

fit_sage <- Arima(returns_sage,order=c(1,0,1))
summary(fit_sage)
```

After fitting ARIMA(1,0,1) to the data, we can see that there is no significant coefficient in the model on the 0.05 significance level.
:::

# Residuals Analysis

::: panel-tabset
## Pfizer

```{r pfizer_residuals}
#| code-fold: true

sarima(returns_pfe, 1,0,2)
pfe.res<-fit_pfe$residuals
```

As we can see from the **Standardized Residuals** plot, there are still volatility clustering around the end of 2019, and 2021. The ACF plot for the residuals shows that the residuals are mostly random, implying that the model has captured the serial correlation in the data effectively. The Quantile-Quantile (Q-Q) plot suggests the residuals are approximately normally distributed. And the Ljung-Box plot shows that some of the p-values are above the 0.05 significance level, which is a good sign.

```{r pfizer_residuals_plot}
#| code-fold: true

plot1<-ggAcf(pfe.res, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot2<- ggPacf(pfe.res, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot1, plot2,nrow=2)

plot3<-ggAcf(pfe.res^2, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 
plot4<- ggPacf(pfe.res^2, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA)) 

grid.arrange(plot3, plot4,nrow=2)
```

After examining the ACF and PACF plots of the residuals and squared residuals, we can see that there are still some correlations at lag 1,2,3,4,5 and so on, which means that the model is not capturing all the information in the data. Fitting a GARCH model might help us capture other correlations.

## Vertex

```{r vertex_residuals}
#| code-fold: true

sarima(returns_vertex, 3,0,3)
vertex.res<-fit_vertex$residuals
```

As we can see from the **Standardized Residuals** plot, the flat, relatively constant line without patterns or structures suggests that the model has captured the time series data's dynamics reasonably well. There's no apparent volatility clustering or obvious trends remaining, which is a good sign. The ACF plot for the residuals shows that the residuals are mostly random, implying that the model has captured the serial correlation in the data effectively. The Quantile-Quantile (Q-Q) plot suggests the residuals are approximately normally distributed. And the Ljung-Box plot shows that many of the p-values are above the 0.05 significance level, which is a good sign.

```{r vertex_residuals_plot}
#| code-fold: true

plot1<-ggAcf(vertex.res, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

plot2<- ggPacf(vertex.res, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

grid.arrange(plot1, plot2,nrow=2)

plot3<-ggAcf(vertex.res^2, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

plot4<- ggPacf(vertex.res^2, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

grid.arrange(plot3, plot4,nrow=2)
```

As we can see from the **Standardized Residuals** plot, and the ACF and PACF plots of the residuals and squared residuals, **there's no need** to fit a GARCH model to the residuals. The residuals are approximately normally distributed, and there's no significant autocorrelation in the residuals, which aligns with the conclusion we got from the `ARCH test`.

## Teva

```{r teva_residuals}
#| code-fold: true

sarima(returns_teva, 1,0,1)
teva.res<-fit_teva$residuals
```

As we can see from the **Standardized Residuals** plot, there are still volatility clustering or high volatility around the end of 2019, 2020, and 2022. The ACF plot for the residuals shows that the residuals are mostly random, implying that the model has captured the serial correlation in the data effectively. The Quantile-Quantile (Q-Q) plot suggests the residuals are approximately normally distributed. And the Ljung-Box plot shows that **all** of the p-values are above the 0.05 significance level, which is a good sign.

```{r teva_residuals_plot}
#| code-fold: true

plot1<-ggAcf(teva.res, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

plot2<- ggPacf(teva.res, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

grid.arrange(plot1, plot2,nrow=2)

plot3<-ggAcf(teva.res^2, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

plot4<- ggPacf(teva.res^2, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

grid.arrange(plot3, plot4,nrow=2)

```

After examining the ACF and PACF plots of the residuals and squared residuals, we can see that there are still some correlations at lag 1,2,3,4,5 and 10, which means that the model is not capturing all the information in the data. Fitting a GARCH model might help us capture other correlations.

## Sage

```{r sage_residuals}
#| code-fold: true

sarima(returns_sage, 1,0,1)
sage.res<-fit_sage$residuals
```

As we can see from the **Standardized Residuals** plot, the flat, relatively constant line without patterns or structures suggests that the model has captured the time series data's dynamics reasonably well. There's no apparent volatility clustering or obvious trends remaining, which is a good sign. The ACF plot for the residuals shows that the residuals are mostly random, implying that the model has captured the serial correlation in the data effectively. The Quantile-Quantile (Q-Q) plot suggests the residuals are approximately normally distributed. And the Ljung-Box plot shows that many of the p-values(especially lag 1) are above the 0.05 significance level, which is a good sign.

```{r sage_residuals_plot}
#| code-fold: true


plot1<-ggAcf(sage.res, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

plot2<- ggPacf(sage.res, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

grid.arrange(plot1, plot2,nrow=2)

plot3<-ggAcf(sage.res^2, 40) + theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

plot4<- ggPacf(sage.res^2, 40)+theme_bw()+
      theme(plot.background = element_rect(color = NA),
            panel.background = element_rect(color = NA))

grid.arrange(plot3, plot4,nrow=2)
```

As we can see from the **Standardized Residuals** plot, and the ACF and PACF plots of the residuals and squared residuals, **there's no need** to fit a GARCH model to the residuals. The residuals are approximately normally distributed, and there's no significant autocorrelation in the residuals, which aligns with the conclusion we got from the `ARCH test`.
:::

# ARIMA + GARCH

::: panel-tabset
## Pfizer

```{r pfizer_arima_garch, warning=FALSE}
#| code-fold: true

model <- list() ## set counter
cc <- 1
for (p in 1:10) {
  for (q in 1:10) {
  
model[[cc]] <- garch(pfe.res,order=c(q,p),trace=F)
cc <- cc + 1
}
} 

## get AIC values for model evaluation
GARCH_AIC <- sapply(model, AIC) ## model with lowest AIC is the best
which(GARCH_AIC == min(GARCH_AIC))
print("The best model according to AIC is:")
model[[which(GARCH_AIC == min(GARCH_AIC))]]
```

As we can see from the result, the best model according to AIC is `GARCH(1,1)`. Then let's do the **Model Evaluation** for the `GARCH(1,1)`, `GARCH(1,2)`, and `GARCH(2,1)` models.

```{r pfizer_arima_garch_examine}
#| code-fold: true

summary(garchFit(~garch(1,1), pfe.res,trace = F))
summary(garchFit(~garch(1,2), pfe.res,trace = F))
summary(garchFit(~garch(2,1), pfe.res,trace = F))
```

All the coefficients are significant for `GARCH(1,1)`. For model `GARCH(1,2)`, the coefficient for `beta2` is not significant, and the coefficient for `beta1` is only significant at 0.1 level. For the `GARCH(2,1)` model, the coefficient for `alpha2` is not significant. Then let's use the `Cross-Validation` to evaluate the above models.

```{r pfizer_arima_garch_cv}
#| code-fold: true


k <- 700 # minimum data length for fitting a model 3324*.2 (20%)
n <- length(returns_pfe)
# n-k 
i=1
err1 = c()
err2 = c()
err3 = c()

rmse1=c()
rmse2=c()
rmse3=c()

for(i in 1:100)
{
  xtrain <- returns_pfe[1:(k-1)+i] 
  xtest <- returns_pfe[k+i] 

  # ARIMA(1,0,2) + GARCH(1,1)
  arima.fit<-Arima(xtrain,order=c(1,0,2),include.drift = TRUE)
  arima.res <- residuals(arima.fit)
  fit1 <- garchFit(~garch(1,1), arima.res,trace = F)
  fcast1 <- predict(fit1, n.ahead=1)
  
  # ARIMA(1,0,2) + GARCH(1,2)
  fit2 <- garchFit(~garch(1,2), arima.res,trace = F)
  fcast2 <- predict(fit2, n.ahead=1)
  
  # ARIMA(1,0,2) + GARCH(2,1)
  fit3 <- garchFit(~garch(2,1), arima.res,trace = F)
  fcast3 <- predict(fit3, n.ahead=1)
  
  err1 = c(err1, (fcast1$meanForecast-xtest)^2)
  err2 = c(err2, (fcast2$meanForecast-xtest)^2)
  err3 = c(err3, (fcast3$meanForecast-xtest)^2)

  
}

RMSE1=sqrt(mean(err1)) 
RMSE2=sqrt(mean(err2))
RMSE3=sqrt(mean(err3))

RMSE1
RMSE2
RMSE3
```

We can see that the RMSE for these three models are so similar to each other. Considering that the `GARCH(1,1)` model has all significant coefficients, we can conclude that the `GARCH(1,1)` model is the best model. In conclusion, the `ARIMA(1,0,2) + GARCH(1,1)` model is the best model for the Pfizer stock returns.

## Vertex

No GARCH model needed. Only `ARIMA(3,0,3)` or `ARMA(3,3)` is needed.

## Teva

```{r teva_arima_garch, warning=FALSE}
#| code-fold: true

model <- list() ## set counter
cc <- 1
for (p in 1:10) {
  for (q in 1:10) {
  
model[[cc]] <- garch(teva.res,order=c(q,p),trace=F)
cc <- cc + 1
}
} 

## get AIC values for model evaluation
GARCH_AIC <- sapply(model, AIC) ## model with lowest AIC is the best
which(GARCH_AIC == min(GARCH_AIC))
print("The best model according to AIC is:")
model[[which(GARCH_AIC == min(GARCH_AIC))]]
```

As we can see from the result, the best model according to AIC is `GARCH(1,1)`. Then let's do the **Model Evaluation** for the `GARCH(1,1)`, `GARCH(1,2)`, and `GARCH(2,1)` models.

```{r teva_arima_garch_examine}
#| code-fold: true

summary(garchFit(~garch(1,1), teva.res,trace = F))
summary(garchFit(~garch(1,2), teva.res,trace = F))
summary(garchFit(~garch(2,1), teva.res,trace = F))
```

All the coefficients are significant for `GARCH(1,1)`. For model `GARCH(1,2)`, the coefficients for `beta1`, `beta2` are not significant. For the `GARCH(2,1)` model, the coefficients for `alpha1`, `alpha2` are not significant. Then let's use the `Cross-Validation` to evaluate the above models.

```{r teva_arima_garch_cv}
#| code-fold: true


k <- 700 # minimum data length for fitting a model 3324*.2 (20%)
n <- length(returns_teva)
# n-k 
i=1
err1 = c()
err2 = c()
err3 = c()

rmse1=c()
rmse2=c()
rmse3=c()

for(i in 1:100)
{
  xtrain <- returns_teva[1:(k-1)+i] 
  xtest <- returns_teva[k+i] 

  # ARIMA(1,0,1) + GARCH(1,1)
  arima.fit<-Arima(xtrain,order=c(1,0,1),include.drift = TRUE)
  arima.res <- residuals(arima.fit)
  fit1 <- garchFit(~garch(1,1), arima.res,trace = F)
  fcast1 <- predict(fit1, n.ahead=1)
  
  # ARIMA(1,0,1) + GARCH(1,2)
  fit2 <- garchFit(~garch(1,2), arima.res,trace = F)
  fcast2 <- predict(fit2, n.ahead=1)
  
  # ARIMA(1,0,1) + GARCH(2,1)
  fit3 <- garchFit(~garch(2,1), arima.res,trace = F)
  fcast3 <- predict(fit3, n.ahead=1)
  
  err1 = c(err1, (fcast1$meanForecast-xtest)^2)
  err2 = c(err2, (fcast2$meanForecast-xtest)^2)
  err3 = c(err3, (fcast3$meanForecast-xtest)^2)

  
}

RMSE1=sqrt(mean(err1)) 
RMSE2=sqrt(mean(err2))
RMSE3=sqrt(mean(err3))

RMSE1
RMSE2
RMSE3
```

The RMSE for these three models are so similar to each other, with only 0.000001 difference. Considering that the `GARCH(1,1)` model has all significant coefficients, we can conclude that the `GARCH(1,1)` model is the best model. In conclusion, the `ARIMA(1,0,1) + GARCH(1,1)` model is the best model for the Teva stock returns.

## Sage

No GARCH model needed. Only `ARIMA(1,0,1)` or `ARMA(1,1)` is needed.
:::

# Final Model Fitting

::: panel-tabset
## Pfizer

```{r pfizer_final_model}
#| code-fold: true

summary(arima.fit_pfe <- Arima(returns_pfe,order=c(1,0,2),include.drift = TRUE))

summary(final.fit_pfe <- garch(order=c(1,1), pfe.res,trace = F))

```

As we can see from the results, for the `ARIMA(1,0,2)` model, most of the parameters are significant. Also, we can see that the error measures are quite low, which indicates that the model fits the data well. For the `GARCH(1,1)` model we used to account for volatility clustering, all the coefficients are significant, and the `Jarque-Bera test` on the residuals shows that the residuals are not normally distributed, which is expected for financial data. The `Box-Ljung test` shows that there is no autocorrelation left. This indicates that the GARCH model does a good job of capturing the autocorrelations in the volatility of the returns.

## Vertex

```{r vertex_final_model, warning=FALSE}
#| code-fold: true

summary(fit_vertex)

# Plot the Box Ljung test
Box.test(residuals(fit_vertex), lag = 20, type = "Ljung-Box")
```

As we can see from the results, for the `ARIMA(1,0,1)` model, the error measures are quite low(eg. **ME, RMSE**), which indicates that the model fits the data well. The `Box-Ljung test` shows that there is no autocorrelation left in the residuals. In other words, our model appears to be adequately capturing the autocorrelation, and there is no significant evidence of leftover patterns in the residuals that the model has not accounted for.

## Teva

```{r teva_final_model}
#| code-fold: true

summary(arima.fit_teva <- Arima(returns_teva,order=c(1,0,1),include.drift = TRUE))

summary(final.fit_teva <- garch(order=c(1,1), teva.res,trace = F))
```

As we can see from the results, for the `ARIMA(1,0,1)` model, the error measures are quite low(eg. **ME, RMSE**), which indicates that the model fits the data well. For the `GARCH(1,1)` model we used to account for volatility clustering, all the coefficients are significant, and the `Jarque-Bera test` on the residuals shows that the residuals are not normally distributed, which is expected for financial data. The `Box-Ljung test` shows that there is no autocorrelation left. This indicates that the GARCH model does a good job of capturing the autocorrelations in the volatility of the returns.

## Sage

```{r sage_final_model}
#| code-fold: true

summary(fit_sage)

# Plot the Box Ljung test
Box.test(residuals(fit_sage), lag = 20, type = "Ljung-Box")

```

As we can see from the results, for the `ARIMA(1,0,1)` model, the error measures are quite low(eg. **ME, RMSE**), which indicates that the model fits the data well. The `Box-Ljung test` shows that there is no autocorrelation left in the residuals. In other words, our model appears to be adequately capturing the autocorrelation, and there is no significant evidence of leftover patterns in the residuals that the model has not accounted for.
:::

# Model Equations

::: panel-tabset
## Pfizer

The best model for the Pfizer stock returns is `ARIMA(1,0,2) + GARCH(1,1)`. The model equations are as follows:

-   **ARIMA(1,0,2)**

$$
(1 - \phi_1 B)Y_t = (1 + \theta_1 B + \theta_2 B^2)\varepsilon_t
$$

-   **GARCH(1,1)**

$$
\sigma_t^2 = \alpha_0 + \alpha_1 \varepsilon_{t-1}^2 + \beta_1 \sigma_{t-1}^2
$$

## Vertex

The best model for the Vertex stock returns is `ARIMA(3,0,3)`. The model equations are as follows:

-   **ARIMA(3,0,3)**

$$
(1 - \phi_1 B - \phi_2 B^2 - \phi_3 B^3)Y_t = (1 + \theta_1 B + \theta_2 B^2 + \theta_3 B^3)\varepsilon_t
$$

## Teva

The best model for the Teva stock returns is `ARIMA(1,0,1) + GARCH(1,1)`. The model equations are as follows:

-   **ARIMA(1,0,1)**

$$
(1 - \phi_1 B)Y_t = (1 + \theta_1 B)\varepsilon_t
$$

-   **GARCH(1,1)**

$$
\sigma_t^2 = \alpha_0 + \alpha_1 \varepsilon_{t-1}^2 + \beta_1 \sigma_{t-1}^2
$$

## Sage

The best model for the Sage stock returns is `ARIMA(1,0,1)`. The model equations are as follows:

-   **ARIMA(1,0,1)**

$$
(1 - \phi_1 B)Y_t = (1 + \theta_1 B)\varepsilon_t
$$
:::

# Volatility Plot

::: panel-tabset
## Pfizer

```{r pfizer_volatility_plot}
#| code-fold: true

final.fit_pfe <- garchFit(~garch(1,1), pfe.res,trace = F)
ht <- final.fit_pfe@h.t 
pfe_all=data.frame(pfizer)
pfe_all <- data.frame(pfizer,rownames(pfe_all))
colnames(pfe_all)[7] = "date"
pfe_all$date<-as.Date(pfe_all$date,"%Y-%m-%d")
data_pfe = data.frame(ht,pfe_all$date[-1])

ggplot(data_pfe, aes(y = ht, x = pfe_all.date..1.)) + 
  geom_line(col = "#27aeef") + 
  ylab('Conditional Variance') + 
  xlab('Date')+
  ggtitle("Volatality plot for Pfizer") + 
  theme_bw()
```

## Vertex

```{r vertex_volatility_plot, message=FALSE}
#| code-fold: true

residuals_vertex <- residuals(fit_vertex)
squared_residuals <- residuals_vertex^2
vertex_all <- data.frame(vertex)
vertex_all <- data.frame(vertex_all, rownames(vertex_all))
colnames(vertex_all)[7] <- "date"
vertex_all$date <- as.Date(vertex_all$date, "%Y-%m-%d")
data_vertex <- data.frame(ht = squared_residuals, date = vertex_all$date[-1])

ggplot(data_vertex, aes(x = date, y = ht)) +
  geom_line(col = "#27aeef") +
  ylab('Conditional Variance') +
  xlab('Date') +
  ggtitle("Volatility Plot for Vertex")+ theme_bw()
```

## Teva

```{r teva_volatility_plot}
#| code-fold: true

final.fit_teva <- garchFit(~garch(1,1), teva.res,trace = F)
ht <- final.fit_teva@h.t
teva_all=data.frame(teva)
teva_all <- data.frame(teva,rownames(teva_all))
colnames(teva_all)[7] = "date"
teva_all$date<-as.Date(teva_all$date,"%Y-%m-%d")
data_teva = data.frame(ht,teva_all$date[-1])

ggplot(data_teva, aes(y = ht, x = teva_all.date..1.)) + 
  geom_line(col = "#27aeef") + 
  ylab('Conditional Variance') + 
  xlab('Date')+
  ggtitle("Volatality plot for Teva") + 
  theme_bw()
```

## Sage

```{r sage_volatility_plot, message=FALSE}
#| code-fold: true

residuals_sage <- residuals(fit_sage)
squared_residuals <- residuals_sage^2
sage_all <- data.frame(sage)
sage_all <- data.frame(sage_all, rownames(sage_all))
colnames(sage_all)[7] <- "date"
sage_all$date <- as.Date(sage_all$date, "%Y-%m-%d")
data_sage <- data.frame(ht = squared_residuals, date = sage_all$date[-1])

ggplot(data_sage, aes(x = date, y = ht)) +
  geom_line(col = "#27aeef") +
  ylab('Conditional Variance') +
  xlab('Date') +
  ggtitle("Volatility Plot for SAGE")+ theme_bw()

```
:::
